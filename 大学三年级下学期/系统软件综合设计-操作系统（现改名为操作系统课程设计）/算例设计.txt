#include<stdio.h>
#include<windows.h>

/*
头文件
*/
#include"D:/大学作业/Os_Kernal/Os_Kernal/Resource_Allocation_Chart.h"

/*
调用静态链接库
*/
#pragma comment (lib, "D:/大学作业/Os_Kernal/Debug/Os_Kernal.lib")

#pragma comment(lib,"static.lib")，这一句是显式的导入静态链接库。
除此之外，还有其他的方法，比如通过设置路径等等，这里不做介绍。

5.静态库的使用。**新建一个项目，比方说一个控制台程序。
首先通过#include把静态库的头文件加进来(注意路径)。
然后右键项目-属性-配置属性-链接器-常规-附加库目录。
把你lib文件所在的目录加进来，可以相对路径也可以绝对路径。
然后通过#pragma comment(lib, “你的静态库名.lib”)，把静态库加进来，就可以使用静态库的函数了。

附加依赖项：在附加依赖项中添加在寻找lib文件目录下需要引用的lib库文件。
（如果不在附加依赖项里填上，就需要在代码里用#pragma comment（lib, “xxx.lib”）来手动指定了。
你写代码读写一个文件需要写明文件名吧，
这个文件名就相当于那个lib , 但读写这个文件可以不写全路径，就是因为有工作目录的存在）

这个要看你用的什么编程工具了，
如果是Microsoft Visual C++，
就可以新建一个工程，
在选工程类型的时候，
就可以选Win32 Dynamic-Link Library或win32 Static Library，
前者是动态链接库，后者是静态库，
你要的是静态库，就选静态库；
工程建好就加入你的.c/.cpp和.h文件，然后编译，
成功后就会自动生成一个.lib库文件，在Debug文件夹中。

静态库: 在程序编译的时候,将库编译进可执行程序中, 运行的时候不需要外部函数库
动态库: 在程序运行的时候,将库加载到程序中,运行的时候需要外部函数库

库文件的头文件是库文件的目录,
因为库文件是保护的,
看不到里面的源码,
所以把函数接口通过头文件来让人调用 .

Linux 下的静态链接库是以.a结尾的二进制文件，
它作为程序的一个模块，
在链接期间被组合到程序中。
和静态链接库相对的是动态链接库（.so文件），
它在程序运行阶段被加载进内存。

制作链接库的目的是希望别人使用我们已经实现的功能，
但又不希望别人看到我们的源代码，
这对商业机构是非常友好的。

进程死锁的检测：绘制资源分配图
建立资源分配图的数据结构描述；
建立绘制资源分配图的例程，包括结点和有向边
可以删除、添加结点或有向边；
可用鼠标在窗口的任意位置指点，确定结点或有向边位置；
可以拖动现有结点的位置，与该结点相连的有向边也随之移动；
可以将资源分配图存入文件，从文件中取出。

资源分配图 数据结构

需要的数据结构：
1）资源结点，一个长度为6的数组（其内值为0~无穷大）（默认在矩阵中是0，但是一旦进行该序号的资源的“添加”初始化，就是至少为1）为0就不画

3）资源到进程的分配边，用一个矩阵表示，其中每个（m，n）处的位置的值是分配的资源数量，该资源分配掉的总资源数不能大该于资源结点的最大资源数
4）进程到资源的申请边，用一个矩阵表示，其中每个（n，m）处的位置是申请的资源，矩阵中有值的位置，最大只能为1，表示申请，最小为0，表示不申请（与分配不同，申请没有限制，可以超过最大资源数）

画图：
1）函数_画资源节点（）{读取资源结点矩阵，把不为0的都拿出来画节点，有没有边不影响，没有边但是有资源的也要画}，节点上有序号（序号是数组下标数+1）（资源数就是该数组下标对于的数组值）

3）函数_画进程到资源的申请有向边{矩阵有，就画，没有就不画，就一条线}
4）函数_画资源到进程的分配有向边（）{矩阵有，就画，线上的值是分配的资源数}

添加：

2）添加资源结点（）{资源数为0不显示，所以添加就是把资源数从0到多}
这个不显示可以通过在申请矩阵和分配矩阵中查找其是否有与其相关值不为0
、、、、、、、、、、、上面好像不需要、、、、、、、、、、、、、

3）添加资源到进程的分配边，矩阵对于位置+1
4）添加进程到资源的申请边，矩阵对于位置+1


删除：

1）删除资源节点（）把其相关矩阵全部置0（无论是请求还是分配）
2）删除进程节点（）把与该进程相关的有向边矩阵全置为0,（无论是请求还是分配）
3）删除申请边（）{申请矩阵的对应值置为0}
4）删除分配边（）{分配矩阵的对应值-1}

PS  对于一些不能进行操作的，到时候报警

存储和读取：
1）资源分配图的存储，就是存储数据结构即可

每次删除任何东西，都要刷新，也就是重新画
每次添加任何东西，都要刷新，也就是重新画

写到这里，好像可以简化：
只需要两个矩阵就行了。6 * 6的
还有一个资源节点数组1 * 6，记录每个资源结点的最大值




······································································································································································································
······································································································································································································
······································································································································································································
······································································································································································································
······································································································································································································
······································································································································································································
······································································································································································································




这里的申请 都是 正在申请
这里的分配 都是 已分配

删除进程：
删除该进程点的所有申请和被分配

删除资源：
删除该资源点的所有分配和被申请

删除进程对资源的请求：
一次只能删除一条，且由于一个进程只能同时对一个资源进行申请，所以删除的前提是有这个申请

删除资源对进程的分配：
一次只能删除一条（多次点击删除多条），删除的前提是有这一条分配线

增加进程对资源的请求：
一次只能增加一条，且由于默认一个进程最多只能同时对一个资源进行请求（*），
所以增加成功的前提是这个进程没有正在对其他资源进行请求

增加资源对进程的分配：
一次只能增加一条，且由于设定了每个资源类的最大资源个数，
所以增加成功的前提是这个资源已经分配掉的资源没有达到最大资源上限

从文件取出：
文件来自D:\Data.txt

存入到文件:
文件存入到Data.txt（刷新）

死锁的检测：
对六个进程进行依次遍历：
首先是进程1，
如果进程1正在申请的的那个资源类，还有剩余的资源数，那么就进程1就完成了
删除进程1，然后开始看进程2；
如果进程1正在申请的的那个资源类，没有剩余的资源数，那么就进程1就无法完成
就开始看进程2；
进程2同理进程1的操作，
何时确定没有死锁？那就是两个矩阵都变成了00000000000000000
何时确定出死锁了？那就是从第一个卡死开始，建议一个flag = 0，这个flag = 6时，则为死锁。

算例设计：
进程死锁的检测：绘制资源分配图。（1-2 人，难度：3）
 建立资源分配图的数据结构描述；
 建立绘制资源分配图的例程，包括结点和有向边；
 可以删除、添加结点或有向边；
 可以将资源分配图存入文件，从文件中取出；
 进程死锁的检测（多做的部分）


详细展示，首先是
我自己设计的数据结构的介绍；
然后各个函数，
然后lib和debug介绍
然后qt代码介绍
然后运行

1）初始化，初始化是一个我设计的死锁状态；
2）删除进程1：进程1和与其有关的线条都没了,资源1的已分配资源被回收，变成0；
3）删除资源6：资源6和与其有关的线条都没了，资源6的已分配资源被回收，变成0；
4）删除进程2对资源3的请求：
5）删除资源3对进程3的分配，可以看到删除一次没有变化，
但是后面的已分配资源数变成2了，因为一共分配了三个；
连续删除三次之后，再刷新就可以看到资源3的分配释放完毕，节点消失。
6）增加进程2对资源3的请求，刷新，可以看到成功；（增加进程4对资源4的请求，刷新，可以看到是不成功的，这是因为一次只能增加一个；）
7）增加资源3对进程1的分配，成功，且资源3的已分配资源数+1；
增加资源3对进程2的分配，成功，且资源3的已经分配资源数+1
增加资源3对进程3的分配，成功，且资源3的已经分配资源数+1，
此时，资源3的已分配资源数来到3，到达上限，
再增加资源3对进程4的分配，就不生效

好
到这里，先不要刷新，我们存入到文件，然后看一下文件
那么现在初始化一下，存入到文件，然后再看一下，可以看到有变化的
然后看一下Datatxt，不错；
然后删除资源1对进程1的分配，刷新一下，
然后存入到文件，
然后看一下Datatxtx，不错
然后现在初始化一下，刷新
然后不进行任何操作，直接从文件取出，然后刷新
完美，相当于调出备份了

最后是检查死锁问题；
初始化一下，
看检查死锁，是Y，确实是死锁状态
然后删除进程1，那么
那么刷新，再次检查死锁，变成N，也就是没有死锁，
刷新，所有进程、资源全部释放，完成！


